<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bete-Saida Pharmacy | Stock Management</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Add Supabase JS Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <style>
        /* [Keep all your existing CSS styles exactly as they are] */
        :root {
            --primary-blue: #0a1f3d;
            --dark-blue: #061224;
            --medium-blue: #1a3a6c;
            --light-blue: #2d5aa0;
            --accent-blue: #3a7bd5;
            --gold: #ffd700;
            --light-gold: #fff8dc;
            --dark-gold: #b8860b;
            --success: #00ff88;
            --warning: #ffaa00;
            --danger: #ff4444;
            --gray: #8da0c7;
            --light: #e6f0ff;
            --flash-green: #00ff00;
            --flash-dark-green: #00cc00;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Times New Roman', Times, serif;
        }

        /* [Keep ALL existing CSS styles - they remain exactly the same] */
        /* ... All your CSS styles remain unchanged ... */
        
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10001;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .connection-status.online {
            background: rgba(0, 255, 136, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }
        
        .connection-status.offline {
            background: rgba(255, 68, 68, 0.2);
            color: var(--danger);
            border: 1px solid var(--danger);
        }
        
        .connection-status.syncing {
            background: rgba(255, 215, 0, 0.2);
            color: var(--gold);
            border: 1px solid var(--gold);
        }

        .sync-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .sync-indicator.online { background: var(--success); }
        .sync-indicator.offline { background: var(--danger); }
        .sync-indicator.syncing { 
            background: var(--gold);
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <!-- Connection Status Indicator -->
    <div class="connection-status offline" id="connectionStatus">
        <span class="sync-indicator offline"></span>
        <span id="statusText">Connecting...</span>
    </div>
    
    <div class="welcome-page" id="welcomePage">
        <button class="fullscreen-toggle" id="fullscreenToggle">
            <i class="fas fa-expand"></i>
        </button>
        <div class="welcome-content">
            <h1 class="welcome-title">Bete-Saida Pharmacy Stock Management</h1>
            <div class="welcome-owner">Esubalew Biyazin</div>
            
            <div class="login-form" id="loginForm">
                <div class="login-input-group">
                    <label for="loginType"><i class="fas fa-user-tag"></i> Login Type</label>
                    <select id="loginType" required>
                        <option value="">Select login type...</option>
                        <option value="user">User</option>
                        <option value="admin">Admin</option>
                    </select>
                </div>
                
                <div class="login-input-group">
                    <label for="password"><i class="fas fa-lock"></i> Password</label>
                    <input type="password" id="password" required placeholder="Enter password...">
                </div>
                
                <div class="login-buttons">
                    <button class="login-btn" id="loginBtn">
                        <i class="fas fa-sign-in-alt"></i>
                        <span>Login</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="particles" id="particles"></div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
    </div>
    
    <!-- [Keep ALL your existing HTML structure - it remains exactly the same] -->
    <!-- ... All your HTML content remains unchanged ... -->
    
    <!-- JavaScript -->
    <script>
        // Configuration
        const DENO_WS_URL = 'wss://ameng-gogs-esubestockb-60.deno.dev/';
        const SUPABASE_URL = 'https://myyfiatwzzumtzkjmmas.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im15eWZpYXR3enp1bXR6a2ptbWFzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAwMDg1NDQsImV4cCI6MjA4NTU4NDU0NH0.XcaXw662IvtchInqM3RMKo3SVWXUT42WSDEDoigalDU';

        class StockSystem {
            constructor() {
                this.stockItems = [];
                this.salesData = [];
                this.transactions = [];
                this.auditTrail = [];
                this.categories = [];
                this.currentId = 1;
                this.salesCounter = 1001;
                this.transactionCounter = 1;
                this.auditCounter = 1;
                this.isEditing = false;
                this.editingId = null;
                this.isLoggedIn = false;
                this.currentUserType = null;
                this.settings = {
                    lowStockThreshold: 20,
                    expiryWarningDays: 60,
                    defaultMarkup: 50.0,
                    defaultVAT: 15.0,
                    overstockAlert: 150,
                    profitMarginAlert: 10,
                    notifyLowStock: true,
                    notifyExpiry: true,
                    notifyOverstock: true,
                    notifyNegativeProfit: true,
                    autoCostCalc: true,
                    autoProfitCalc: true,
                    autoMarginCalc: true
                };
                
                // Supabase client
                this.supabase = null;
                this.supabaseInitialized = false;
                
                // WebSocket
                this.ws = null;
                this.wsConnected = false;
                this.wsReconnectAttempts = 0;
                this.maxWsReconnectAttempts = 5;
                
                // Sync state
                this.isSyncing = false;
                this.syncQueue = [];
                this.lastSyncTime = null;
                
                this.init();
            }
            
            async init() {
                this.createParticles();
                this.initSupabase();
                this.initWebSocket();
                await this.loadFromLocalStorage(); // Load from localStorage first
                
                document.getElementById('welcomePage').style.display = 'flex';
                document.getElementById('mainContainer').style.display = 'none';
                
                this.setupRealTimeCalculations();
                
                document.getElementById('loading').style.display = 'none';
                
                this.setupAllClickableElements();
                
                // Start sync process
                this.startAutoSync();
            }
            
            initSupabase() {
                try {
                    this.supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                    this.supabaseInitialized = true;
                    this.updateConnectionStatus('supabase_connected', 'Supabase connected');
                } catch (error) {
                    console.error('Failed to initialize Supabase:', error);
                    this.updateConnectionStatus('supabase_error', 'Supabase connection failed');
                }
            }
            
            initWebSocket() {
                try {
                    this.ws = new WebSocket(DENO_WS_URL);
                    
                    this.ws.onopen = () => {
                        this.wsConnected = true;
                        this.wsReconnectAttempts = 0;
                        this.updateConnectionStatus('ws_connected', 'Real-time connected');
                        console.log('WebSocket connected');
                        
                        // Send authentication if logged in
                        if (this.isLoggedIn) {
                            this.sendWsAuth();
                        }
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (error) {
                            console.error('Failed to parse WebSocket message:', error);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        this.wsConnected = false;
                        this.updateConnectionStatus('ws_disconnected', 'Real-time disconnected');
                        console.log('WebSocket disconnected');
                        
                        // Attempt to reconnect
                        if (this.wsReconnectAttempts < this.maxWsReconnectAttempts) {
                            this.wsReconnectAttempts++;
                            setTimeout(() => {
                                console.log(`Attempting to reconnect (${this.wsReconnectAttempts}/${this.maxWsReconnectAttempts})`);
                                this.initWebSocket();
                            }, 3000 * this.wsReconnectAttempts);
                        }
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateConnectionStatus('ws_error', 'Real-time error');
                    };
                } catch (error) {
                    console.error('Failed to initialize WebSocket:', error);
                    this.updateConnectionStatus('ws_error', 'WebSocket failed');
                }
            }
            
            updateConnectionStatus(type, message) {
                const statusElement = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                if (!statusElement || !statusText) return;
                
                let statusClass = 'offline';
                let indicatorClass = 'offline';
                let displayText = message;
                
                switch(type) {
                    case 'supabase_connected':
                    case 'ws_connected':
                        statusClass = 'online';
                        indicatorClass = 'online';
                        break;
                    case 'syncing':
                        statusClass = 'syncing';
                        indicatorClass = 'syncing';
                        break;
                    case 'supabase_error':
                    case 'ws_error':
                    case 'ws_disconnected':
                        statusClass = 'offline';
                        indicatorClass = 'offline';
                        break;
                }
                
                // Update UI
                statusElement.className = `connection-status ${statusClass}`;
                statusElement.querySelector('.sync-indicator').className = `sync-indicator ${indicatorClass}`;
                statusText.textContent = displayText;
                
                // Auto-hide success messages after 3 seconds
                if (type === 'syncing' || type === 'supabase_connected' || type === 'ws_connected') {
                    setTimeout(() => {
                        if (this.wsConnected && this.supabaseInitialized) {
                            statusText.textContent = 'Online';
                        }
                    }, 3000);
                }
            }
            
            async startAutoSync() {
                // Initial sync
                await this.syncWithCloud();
                
                // Auto-sync every 30 seconds
                setInterval(async () => {
                    if (this.wsConnected && this.supabaseInitialized && this.isLoggedIn) {
                        await this.syncWithCloud();
                    }
                }, 30000);
            }
            
            async syncWithCloud() {
                if (this.isSyncing) return;
                
                this.isSyncing = true;
                this.updateConnectionStatus('syncing', 'Syncing with cloud...');
                
                try {
                    // Sync stock items
                    await this.syncStockItems();
                    
                    // Sync sales data
                    await this.syncSalesData();
                    
                    // Sync transactions
                    await this.syncTransactions();
                    
                    // Sync audit trail
                    await this.syncAuditTrail();
                    
                    // Process sync queue
                    await this.processSyncQueue();
                    
                    this.lastSyncTime = new Date();
                    console.log('Cloud sync completed successfully');
                } catch (error) {
                    console.error('Cloud sync failed:', error);
                } finally {
                    this.isSyncing = false;
                    if (this.wsConnected && this.supabaseInitialized) {
                        this.updateConnectionStatus('ws_connected', 'Sync completed');
                    }
                }
            }
            
            async syncStockItems() {
                if (!this.supabaseInitialized) return;
                
                try {
                    // Load from Supabase
                    const { data, error } = await this.supabase
                        .from('stock_items')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    if (data && data.length > 0) {
                        // Merge with local data
                        const remoteItems = data;
                        const localItems = this.stockItems;
                        
                        // Create a map of remote items by id
                        const remoteMap = new Map();
                        remoteItems.forEach(item => remoteMap.set(item.id, item));
                        
                        // Update or add remote items
                        remoteItems.forEach(remoteItem => {
                            const localIndex = localItems.findIndex(item => item.id === remoteItem.id);
                            if (localIndex !== -1) {
                                // Update local with remote if remote is newer
                                const localItem = localItems[localIndex];
                                const remoteUpdated = new Date(remoteItem.updated_at);
                                const localUpdated = new Date(localItem.updated_at);
                                
                                if (remoteUpdated > localUpdated) {
                                    localItems[localIndex] = remoteItem;
                                }
                            } else {
                                // Add new remote item
                                localItems.push(remoteItem);
                            }
                        });
                        
                        // Send local items that don't exist remotely
                        localItems.forEach(localItem => {
                            if (!remoteMap.has(localItem.id)) {
                                this.queueForSync('stock_items', 'create', localItem);
                            }
                        });
                        
                        this.stockItems = localItems;
                        this.saveToLocalStorage();
                        
                        // Update UI if inventory page is active
                        if (document.getElementById('stockInventoryPage').classList.contains('active')) {
                            this.renderTable();
                        }
                    }
                } catch (error) {
                    console.error('Failed to sync stock items:', error);
                }
            }
            
            async syncSalesData() {
                if (!this.supabaseInitialized) return;
                
                try {
                    const { data, error } = await this.supabase
                        .from('sales')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    if (data && data.length > 0) {
                        // Merge logic similar to stock items
                        const remoteSales = data;
                        const localSales = this.salesData;
                        
                        const remoteMap = new Map();
                        remoteSales.forEach(sale => remoteMap.set(sale.id, sale));
                        
                        remoteSales.forEach(remoteSale => {
                            const localIndex = localSales.findIndex(sale => sale.id === remoteSale.id);
                            if (localIndex !== -1) {
                                const localSale = localSales[localIndex];
                                const remoteUpdated = new Date(remoteSale.updated_at);
                                const localUpdated = new Date(localSale.updated_at);
                                
                                if (remoteUpdated > localUpdated) {
                                    localSales[localIndex] = remoteSale;
                                }
                            } else {
                                localSales.push(remoteSale);
                            }
                        });
                        
                        localSales.forEach(localSale => {
                            if (!remoteMap.has(localSale.id)) {
                                this.queueForSync('sales', 'create', localSale);
                            }
                        });
                        
                        this.salesData = localSales;
                        this.saveToLocalStorage();
                    }
                } catch (error) {
                    console.error('Failed to sync sales data:', error);
                }
            }
            
            async syncTransactions() {
                if (!this.supabaseInitialized) return;
                
                try {
                    const { data, error } = await this.supabase
                        .from('transactions')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    if (data && data.length > 0) {
                        // Similar merge logic
                        this.transactions = data;
                        this.saveToLocalStorage();
                    }
                } catch (error) {
                    console.error('Failed to sync transactions:', error);
                }
            }
            
            async syncAuditTrail() {
                if (!this.supabaseInitialized) return;
                
                try {
                    const { data, error } = await this.supabase
                        .from('audit_trail')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    if (data && data.length > 0) {
                        this.auditTrail = data;
                        this.saveToLocalStorage();
                        
                        // Update UI if audit page is active
                        if (document.getElementById('auditPage').classList.contains('active')) {
                            this.runAuditReport();
                        }
                    }
                } catch (error) {
                    console.error('Failed to sync audit trail:', error);
                }
            }
            
            queueForSync(table, action, data) {
                this.syncQueue.push({
                    table,
                    action,
                    data,
                    timestamp: new Date().toISOString()
                });
                
                // Process queue immediately if online
                if (this.wsConnected && this.supabaseInitialized) {
                    this.processSyncQueue();
                }
            }
            
            async processSyncQueue() {
                if (this.syncQueue.length === 0 || !this.supabaseInitialized) return;
                
                const queue = [...this.syncQueue];
                this.syncQueue = [];
                
                for (const item of queue) {
                    try {
                        switch (item.action) {
                            case 'create':
                                const { error } = await this.supabase
                                    .from(item.table)
                                    .insert(item.data);
                                
                                if (error) {
                                    // Re-queue if failed
                                    this.syncQueue.push(item);
                                    throw error;
                                }
                                break;
                                
                            case 'update':
                                await this.supabase
                                    .from(item.table)
                                    .update(item.data)
                                    .eq('id', item.data.id);
                                break;
                                
                            case 'delete':
                                await this.supabase
                                    .from(item.table)
                                    .delete()
                                    .eq('id', item.data.id);
                                break;
                        }
                    } catch (error) {
                        console.error(`Failed to sync ${item.table}:`, error);
                    }
                }
            }
            
            sendWsAuth() {
                if (!this.wsConnected || !this.isLoggedIn) return;
                
                const authMessage = {
                    type: 'auth',
                    userType: this.currentUserType,
                    timestamp: new Date().toISOString()
                };
                
                this.ws.send(JSON.stringify(authMessage));
            }
            
            sendWsUpdate(table, action, data) {
                if (!this.wsConnected) return;
                
                const updateMessage = {
                    type: 'update',
                    table,
                    action,
                    data,
                    timestamp: new Date().toISOString(),
                    userId: this.currentUserType
                };
                
                this.ws.send(JSON.stringify(updateMessage));
            }
            
            handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'update':
                        this.handleRemoteUpdate(data);
                        break;
                        
                    case 'notification':
                        this.showToast(data.message, data.level || 'info');
                        break;
                        
                    case 'sync_request':
                        this.syncWithCloud();
                        break;
                        
                    case 'user_connected':
                        console.log(`User connected: ${data.userId}`);
                        break;
                        
                    case 'user_disconnected':
                        console.log(`User disconnected: ${data.userId}`);
                        break;
                }
            }
            
            handleRemoteUpdate(data) {
                // Don't process our own updates
                if (data.userId === this.currentUserType) return;
                
                switch (data.table) {
                    case 'stock_items':
                        this.handleStockItemUpdate(data);
                        break;
                        
                    case 'sales':
                        this.handleSalesUpdate(data);
                        break;
                        
                    case 'audit_trail':
                        this.handleAuditUpdate(data);
                        break;
                }
                
                // Show notification
                this.showToast(`Remote update: ${data.action} on ${data.table}`, 'info');
            }
            
            handleStockItemUpdate(data) {
                const item = data.data;
                
                switch (data.action) {
                    case 'create':
                        // Check if item already exists
                        const exists = this.stockItems.find(i => i.id === item.id);
                        if (!exists) {
                            this.stockItems.push(item);
                            this.saveToLocalStorage();
                            
                            if (document.getElementById('stockInventoryPage').classList.contains('active')) {
                                this.renderTable();
                            }
                        }
                        break;
                        
                    case 'update':
                        const index = this.stockItems.findIndex(i => i.id === item.id);
                        if (index !== -1) {
                            this.stockItems[index] = item;
                            this.saveToLocalStorage();
                            
                            if (document.getElementById('stockInventoryPage').classList.contains('active')) {
                                this.renderTable();
                            }
                        }
                        break;
                        
                    case 'delete':
                        const deleteIndex = this.stockItems.findIndex(i => i.id === item.id);
                        if (deleteIndex !== -1) {
                            this.stockItems.splice(deleteIndex, 1);
                            this.saveToLocalStorage();
                            
                            if (document.getElementById('stockInventoryPage').classList.contains('active')) {
                                this.renderTable();
                            }
                        }
                        break;
                }
            }
            
            handleSalesUpdate(data) {
                // Similar implementation for sales updates
                const sale = data.data;
                
                switch (data.action) {
                    case 'create':
                        const exists = this.salesData.find(s => s.id === sale.id);
                        if (!exists) {
                            this.salesData.push(sale);
                            this.saveToLocalStorage();
                        }
                        break;
                        
                    case 'update':
                        const index = this.salesData.findIndex(s => s.id === sale.id);
                        if (index !== -1) {
                            this.salesData[index] = sale;
                            this.saveToLocalStorage();
                        }
                        break;
                }
            }
            
            handleAuditUpdate(data) {
                const audit = data.data;
                
                if (data.action === 'create') {
                    this.auditTrail.unshift(audit);
                    this.saveToLocalStorage();
                    
                    if (document.getElementById('auditPage').classList.contains('active')) {
                        this.runAuditReport();
                    }
                }
            }
            
            async saveItem() {
                const registeredToBaseFactor = parseFloat(document.getElementById('registeredToBaseFactor').value) || 1;
                const displayToBaseFactor = parseFloat(document.getElementById('displayToBaseFactor').value) || 1;
                const quantityType = document.getElementById('initialQuantityType').value;
                const quantity = parseFloat(document.getElementById('initialQuantity').value) || 0;
                
                if (registeredToBaseFactor <= 0 || displayToBaseFactor <= 0) {
                    this.showToast('Conversion factors must be greater than 0', 'warning');
                    return;
                }
                
                let baseQuantity = 0;
                switch(quantityType) {
                    case 'registered':
                        baseQuantity = quantity * registeredToBaseFactor;
                        break;
                    case 'display':
                        baseQuantity = quantity * displayToBaseFactor;
                        break;
                    case 'base':
                        baseQuantity = quantity;
                        break;
                }
                
                const itemData = {
                    id: this.isEditing ? this.editingId : this.currentId++,
                    name: document.getElementById('itemName').value.trim(),
                    category: document.getElementById('category').value,
                    base_unit: document.getElementById('baseUnit').value,
                    registered_unit: document.getElementById('registeredUnit').value.trim(),
                    registered_to_base_factor: registeredToBaseFactor,
                    display_unit: document.getElementById('displayUnit').value.trim(),
                    display_to_base_factor: displayToBaseFactor,
                    allow_fractional_display: document.getElementById('allowFractionalDisplay').value === 'true',
                    quantity_base: baseQuantity,
                    purchase_price_per_display: parseFloat(document.getElementById('purchasePricePerDisplay').value) || 0,
                    markup: parseFloat(document.getElementById('markup').value) || 0,
                    selling_price_per_display: parseFloat(document.getElementById('sellingPricePerDisplay').value) || 0,
                    batch_number: document.getElementById('batchNumber').value.trim(),
                    expiry_date: document.getElementById('expiryDate').value,
                    supplier: document.getElementById('supplier').value.trim(),
                    registrant: document.getElementById('registrant').value.trim(),
                    branch: document.getElementById('branch').value,
                    storage_location: document.getElementById('storageLocation').value.trim(),
                    min_stock_base: parseInt(document.getElementById('minStockBase').value) || 10,
                    max_stock_base: parseInt(document.getElementById('maxStockBase').value) || 100,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                };
                
                if (!itemData.name || !itemData.category || !itemData.base_unit || 
                    !itemData.registered_unit || !itemData.display_unit || 
                    baseQuantity < 0 || !itemData.batch_number || !itemData.supplier || 
                    !itemData.registrant) {
                    this.showToast('Please fill all required fields correctly', 'warning');
                    return;
                }
                
                if (this.isEditing) {
                    const index = this.stockItems.findIndex(i => i.id === itemData.id);
                    this.stockItems[index] = itemData;
                    
                    // Update in cloud
                    this.queueForSync('stock_items', 'update', itemData);
                    this.sendWsUpdate('stock_items', 'update', itemData);
                    
                    this.recordAudit('edit', itemData.id, itemData.name, itemData.quantity_base, 
                                   'item_updated', itemData.branch, itemData.registrant);
                } else {
                    this.stockItems.push(itemData);
                    
                    // Save to cloud
                    this.queueForSync('stock_items', 'create', itemData);
                    this.sendWsUpdate('stock_items', 'create', itemData);
                    
                    this.recordTransaction('addition', itemData.id, itemData.name, itemData.quantity_base, 
                                          'new_item', itemData.branch, itemData.purchase_price_per_display, 
                                          itemData.registrant, itemData.display_unit);
                    this.recordAudit('create', itemData.id, itemData.name, itemData.quantity_base, 
                                   'item_registered', itemData.branch, itemData.registrant);
                }
                
                this.saveToLocalStorage();
                this.clearForm();
                this.showToast(`Item ${this.isEditing ? 'updated' : 'registered'} successfully!`, 'success');
                this.isEditing = false;
                this.editingId = null;
            }
            
            async processSale() {
                const items = [];
                let isValid = true;
                
                document.querySelectorAll('#salesItemsBody tr').forEach(row => {
                    const searchInput = row.querySelector('.sales-item-search');
                    const quantityInput = row.querySelector('.sales-quantity');
                    
                    if (!searchInput.value || !quantityInput.value || parseFloat(quantityInput.value) <= 0) {
                        isValid = false;
                        return;
                    }
                    
                    const stockItem = this.stockItems.find(item => item.name.toLowerCase() === searchInput.value.trim().toLowerCase());
                    if (!stockItem) {
                        isValid = false;
                        return;
                    }
                    
                    const quantity = parseFloat(quantityInput.value);
                    const maxDisplayQuantity = stockItem.quantity_base / stockItem.display_to_base_factor;
                    
                    if (quantity > maxDisplayQuantity) {
                        isValid = false;
                        this.showToast(`Insufficient stock for ${stockItem.name}. Available: ${maxDisplayQuantity.toFixed(2)} ${stockItem.display_unit}`, 'warning');
                        return;
                    }
                    
                    const baseQuantity = quantity * stockItem.display_to_base_factor;
                    const unitPrice = parseFloat(row.querySelector('.sales-unit-price').value);
                    const discount = parseFloat(row.querySelector('.sales-discount').value) || 0;
                    const vat = parseFloat(row.querySelector('.sales-vat').value) || 0;
                    const subtotal = quantity * unitPrice;
                    const vatAmount = subtotal * (vat / 100);
                    const netAmount = subtotal + vatAmount - discount;
                    const costPerBaseUnit = stockItem.purchase_price_per_display / stockItem.display_to_base_factor;
                    const totalCost = baseQuantity * costPerBaseUnit;
                    
                    items.push({
                        item_id: stockItem.id,
                        name: stockItem.name,
                        batch: row.querySelector('.sales-batch').value,
                        base_unit: stockItem.base_unit,
                        display_unit: stockItem.display_unit,
                        display_to_base_factor: stockItem.display_to_base_factor,
                        quantity: quantity,
                        quantity_base: baseQuantity,
                        cost_price: costPerBaseUnit,
                        unit_price: unitPrice,
                        discount: discount,
                        vat: vat,
                        subtotal: subtotal,
                        vat_amount: vatAmount,
                        net_amount: netAmount,
                        profit: netAmount - totalCost,
                        margin: costPerBaseUnit > 0 ? ((unitPrice - (costPerBaseUnit * stockItem.display_to_base_factor)) / (costPerBaseUnit * stockItem.display_to_base_factor) * 100) : 0
                    });
                });
                
                if (!isValid || items.length === 0) {
                    this.showToast('Please fill all item details correctly', 'warning');
                    return;
                }
                
                // Generate invoice number
                const invoiceNumber = `INV-${new Date().getFullYear()}${(new Date().getMonth()+1).toString().padStart(2,'0')}${this.salesCounter.toString().padStart(4,'0')}`;
                
                // Create sale record
                const saleRecord = {
                    id: this.salesCounter++,
                    invoice_number: invoiceNumber,
                    date: document.getElementById('salesDate').value,
                    branch: document.getElementById('salesBranch').value,
                    payment_method: document.getElementById('salesPaymentMethod').value,
                    salesperson: document.getElementById('salesperson').value,
                    approver: document.getElementById('salesApprover').value || '',
                    items: items,
                    subtotal: parseFloat(document.getElementById('salesSubtotal').textContent.replace('ETB ', '')),
                    discount: parseFloat(document.getElementById('salesTotalDiscount').textContent.replace('ETB ', '')),
                    vat: parseFloat(document.getElementById('salesTotalVAT').textContent.replace('ETB ', '')),
                    grand_total: parseFloat(document.getElementById('salesGrandTotal').textContent.replace('ETB ', '')),
                    cogs: parseFloat(document.getElementById('salesCOGS').textContent.replace('ETB ', '')),
                    gross_profit: parseFloat(document.getElementById('salesGrossProfit').textContent.replace('ETB ', '')),
                    profit_margin: parseFloat(document.getElementById('salesProfitMargin').textContent.replace('%', '')),
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                };
                
                // Update stock quantities and record transactions
                items.forEach(item => {
                    const stockItem = this.stockItems.find(i => i.id == item.item_id);
                    if (stockItem) {
                        stockItem.quantity_base -= item.quantity_base;
                        stockItem.updated_at = new Date().toISOString();
                        
                        // Update stock in cloud
                        this.queueForSync('stock_items', 'update', stockItem);
                        this.sendWsUpdate('stock_items', 'update', stockItem);
                        
                        this.recordTransaction('deduction', stockItem.id, stockItem.name, item.quantity_base, 
                                              'sale', saleRecord.branch, item.unit_price, saleRecord.salesperson, item.display_unit);
                        
                        // Record audit for sale
                        this.recordAudit('sale', stockItem.id, stockItem.name, item.quantity_base, 
                                       'sale_outflow', saleRecord.branch, saleRecord.salesperson, {
                                           invoice: saleRecord.invoice_number,
                                           unit_price: item.unit_price,
                                           profit: item.profit,
                                           margin: item.margin,
                                           discount: item.discount
                                       });
                    }
                });
                
                // Save sale to cloud
                this.queueForSync('sales', 'create', saleRecord);
                this.sendWsUpdate('sales', 'create', saleRecord);
                
                this.salesData.push(saleRecord);
                this.saveToLocalStorage();
                this.showToast(`Sale saved! Invoice: ${saleRecord.invoice_number}`, 'success');
                this.clearSalesForm();
            }
            
            async addStock() {
                const itemId = document.getElementById('addItemSelect').value;
                if (!itemId) {
                    this.showToast('Please select an item', 'warning');
                    return;
                }
                
                const stockItem = this.stockItems.find(item => item.id == itemId);
                if (!stockItem) {
                    this.showToast('Item not found', 'warning');
                    return;
                }
                
                const quantity = parseFloat(document.getElementById('addQuantity').value) || 0;
                if (quantity <= 0) {
                    this.showToast('Please enter valid quantity', 'warning');
                    return;
                }
                
                const quantityType = document.getElementById('addQuantityType').value;
                if (!quantityType) {
                    this.showToast('Please select quantity type', 'warning');
                    return;
                }
                
                let baseQuantity = 0;
                switch(quantityType) {
                    case 'registered':
                        baseQuantity = quantity * stockItem.registered_to_base_factor;
                        break;
                    case 'display':
                        baseQuantity = quantity * stockItem.display_to_base_factor;
                        break;
                    case 'base':
                        baseQuantity = quantity;
                        break;
                }
                
                const unitPrice = parseFloat(document.getElementById('addUnitPrice').value) || 0;
                const markup = parseFloat(document.getElementById('addMarkup').value) || 0;
                const sellingPrice = parseFloat(document.getElementById('addSellingPrice').value) || 0;
                
                if (unitPrice <= 0 || sellingPrice <= 0) {
                    this.showToast('Please enter valid prices', 'warning');
                    return;
                }
                
                // Update stock item
                stockItem.quantity_base += baseQuantity;
                stockItem.purchase_price_per_display = unitPrice;
                stockItem.markup = markup;
                stockItem.selling_price_per_display = sellingPrice;
                stockItem.branch = document.getElementById('addBranch').value;
                stockItem.updated_at = new Date().toISOString();
                
                // Update optional fields if provided
                const newBatch = document.getElementById('addBatchNumber').value.trim();
                const newExpiry = document.getElementById('addExpiryDate').value;
                const newSupplier = document.getElementById('addSupplier').value.trim();
                const newStorage = document.getElementById('addStorageLocation').value.trim();
                const approvedBy = document.getElementById('addApprovedBy').value.trim();
                
                if (newBatch) stockItem.batch_number = newBatch;
                if (newExpiry) stockItem.expiry_date = newExpiry;
                if (newSupplier) stockItem.supplier = newSupplier;
                if (newStorage) stockItem.storage_location = newStorage;
                
                // Update in cloud
                this.queueForSync('stock_items', 'update', stockItem);
                this.sendWsUpdate('stock_items', 'update', stockItem);
                
                // Record transaction and audit
                const reason = document.getElementById('addReason').value;
                this.recordTransaction('addition', stockItem.id, stockItem.name, baseQuantity, 
                                      reason, stockItem.branch, unitPrice, 'System', stockItem.display_unit);
                
                this.recordAudit('purchase', stockItem.id, stockItem.name, baseQuantity,
                               'purchase_inflow', stockItem.branch, 'System', {
                                   unit_price: unitPrice,
                                   selling_price: sellingPrice,
                                   markup: markup,
                                   approved_by: approvedBy
                               });
                
                this.saveToLocalStorage();
                this.clearAddStockForm();
                const displayQuantity = baseQuantity / stockItem.display_to_base_factor;
                this.showToast(`Added ${displayQuantity.toFixed(2)} ${stockItem.display_unit} to ${stockItem.name}`, 'success');
            }
            
            async reduceStock() {
                const itemId = document.getElementById('reduceItemSelect').value;
                if (!itemId) {
                    this.showToast('Please select an item', 'warning');
                    return;
                }
                
                const stockItem = this.stockItems.find(item => item.id == itemId);
                if (!stockItem) {
                    this.showToast('Item not found', 'warning');
                    return;
                }
                
                const quantity = parseFloat(document.getElementById('reduceQuantity').value) || 0;
                const baseQuantity = quantity * stockItem.display_to_base_factor;
                
                if (quantity <= 0 || baseQuantity > stockItem.quantity_base) {
                    const availableDisplay = stockItem.quantity_base / stockItem.display_to_base_factor;
                    this.showToast(`Invalid quantity. Available: ${availableDisplay.toFixed(2)} ${stockItem.display_unit}`, 'warning');
                    return;
                }
                
                const whom = document.getElementById('whom').value.trim();
                if (!whom) {
                    this.showToast('Please enter responsible person name', 'warning');
                    return;
                }
                
                const approver = document.getElementById('approver').value.trim();
                const reason = document.getElementById('reduceReason').value;
                const notes = document.getElementById('reduceNotes').value.trim();
                
                // Update stock item
                stockItem.quantity_base -= baseQuantity;
                stockItem.updated_at = new Date().toISOString();
                
                // Update in cloud
                this.queueForSync('stock_items', 'update', stockItem);
                this.sendWsUpdate('stock_items', 'update', stockItem);
                
                // Record transaction and audit
                this.recordTransaction('deduction', stockItem.id, stockItem.name, baseQuantity, 
                                      reason, document.getElementById('reduceBranch').value, 
                                      stockItem.purchase_price_per_display, whom, stockItem.display_unit);
                
                const auditType = this.getAuditTypeForReason(reason);
                this.recordAudit(auditType, stockItem.id, stockItem.name, baseQuantity,
                               `stock_${reason}`, document.getElementById('reduceBranch').value, whom, {
                                   approver: approver,
                                   notes: notes,
                                   unit_value: stockItem.purchase_price_per_display / stockItem.display_to_base_factor,
                                   total_loss: baseQuantity * (stockItem.purchase_price_per_display / stockItem.display_to_base_factor)
                               });
                
                this.saveToLocalStorage();
                this.clearDeductStockForm();
                this.showToast(`Deducted ${quantity} ${stockItem.display_unit} from ${stockItem.name}`, 'success');
            }
            
            recordAudit(action, itemId, itemName, quantityBase, eventType, branch, user, details = {}) {
                const audit = {
                    id: this.auditCounter++,
                    action: action,
                    item_id: itemId,
                    item_name: itemName,
                    quantity: quantityBase || 0,
                    event_type: eventType,
                    branch: branch,
                    user: user,
                    details: details,
                    created_at: new Date().toISOString(),
                    date: new Date().toISOString().split('T')[0],
                    time: new Date().toLocaleTimeString(),
                    approval_status: details.approver ? 'Approved' : 'Pending'
                };
                
                this.auditTrail.push(audit);
                
                // Save to cloud
                this.queueForSync('audit_trail', 'create', audit);
                this.sendWsUpdate('audit_trail', 'create', audit);
                
                this.saveToLocalStorage();
                
                if (document.getElementById('auditPage').classList.contains('active')) {
                    this.updateAuditSummary();
                }
            }
            
            handleLogin() {
                const loginType = document.getElementById('loginType').value;
                const password = document.getElementById('password').value;
                
                if (!loginType) {
                    this.showToast('Please select login type', 'warning');
                    return;
                }
                
                if (loginType === 'user' && password === '123456') {
                    this.isLoggedIn = true;
                    this.currentUserType = 'user';
                    this.showLoginSuccess();
                    
                    // Send WebSocket authentication
                    this.sendWsAuth();
                    
                    // Start syncing
                    this.syncWithCloud();
                } else if (loginType === 'admin' && password === 'esubalew2123') {
                    this.isLoggedIn = true;
                    this.currentUserType = 'admin';
                    this.showLoginSuccess();
                    
                    // Send WebSocket authentication
                    this.sendWsAuth();
                    
                    // Start syncing
                    this.syncWithCloud();
                } else {
                    this.showToast('Invalid password. Please try again.', 'warning');
                }
            }
            
            showLoginSuccess() {
                document.getElementById('welcomePage').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('welcomePage').style.display = 'none';
                    document.getElementById('mainContainer').style.display = 'block';
                    this.setupUserInterface();
                    this.showToast('Login successful! Welcome to Bete-Saida Pharmacy System.', 'success');
                }, 300);
            }
            
            // [Keep all other existing methods exactly as they are]
            // ... All other methods remain unchanged ...
            
            // Only add the new methods above and modify the existing ones as shown
            
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            window.stockSystem = new StockSystem();
        });
    </script>
</body>
</html>
